from langchain.tools import BaseTool
from typing import Optional, Type
from pydantic import BaseModel, Field
import subprocess
import os

class ScriptExecutionInput(BaseModel):
    """Input for ScriptExecutionTool."""
    script_number: int = Field(description="The number of the script to execute from generated_scripts directory")
    timeout: Optional[int] = Field(default=60, description="Timeout in seconds for script execution")

class ScriptExecutionTool(BaseTool):
    """Tool for executing generated bash scripts in a Kali Linux environment.
    
    This tool is designed to safely execute generated bash scripts in a controlled environment.
    It handles script execution, output capture, and error handling. The tool is specifically
    designed to work with scripts generated by an LLM and stored in the generated_scripts directory.
    
    Attributes:
        name (str): The name of the tool
        description (str): A description of what the tool does
        args_schema (Type[BaseModel]): The Pydantic model defining the input schema
    """
    
    name: str = "script_executor"
    description: str = """Execute a generated bash script and return its output. 
    The script must exist in the generated_scripts directory and be properly formatted.
    Returns the execution results including stdout, stderr, and execution status."""
    args_schema: Type[BaseModel] = ScriptExecutionInput

    def _run(self, script_number: int, timeout: int = 60) -> dict:
        """Execute the specified script and return its output.
        
        Args:
            script_number (int): The number of the script to execute
            timeout (int, optional): Timeout in seconds. Defaults to 60.
            
        Returns:
            dict: A dictionary containing:
                - success (bool): Whether the execution was successful
                - output (str): stdout from the script
                - error (str, optional): stderr if execution failed
                - script_path (str): Path to the executed script
                
        Raises:
            FileNotFoundError: If the script doesn't exist
            subprocess.TimeoutExpired: If the script execution times out
            Exception: For other execution errors
        """
        script_path = f"generated_scripts/command_{script_number}.sh"
        
        if not os.path.exists(script_path):
            raise FileNotFoundError(f"Script {script_path} not found. Generate a script first.")
        
        try:
            # Run the script and capture output
            result = subprocess.run(
                [script_path],
                capture_output=True,
                text=True,
                check=True,
                timeout=timeout
            )
            
            return {
                "success": True,
                "output": result.stdout,
                "script_path": script_path
            }
            
        except subprocess.TimeoutExpired as e:
            return {
                "success": False,
                "error": f"Script execution timed out after {timeout} seconds",
                "output": e.stdout.decode() if e.stdout else "",
                "script_path": script_path
            }
        except subprocess.CalledProcessError as e:
            return {
                "success": False,
                "error": str(e),
                "output": e.stderr,
                "script_path": script_path
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "script_path": script_path
            }

    async def _arun(self, script_number: int, timeout: int = 60) -> dict:
        """Async version of the script execution.
        
        This is a placeholder that calls the sync version, as the current implementation
        doesn't require async execution. For true async execution, this would need to be
        implemented using asyncio.subprocess.
        """
        return self._run(script_number=script_number, timeout=timeout) 